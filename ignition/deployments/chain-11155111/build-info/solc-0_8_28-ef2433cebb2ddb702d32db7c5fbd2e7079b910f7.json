{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-ef2433cebb2ddb702d32db7c5fbd2e7079b910f7",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ProofHTF.sol": "project/contracts/ProofHTF.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ProofHTF.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\ncontract ProofHTF {\n    // Enums\n    enum Role {\n        TUTOR,\n        STUDENT\n    }\n\n    struct User {\n        string name;\n        Role role;\n        bool isRegistered;\n    }\n\n    struct Course {\n        uint256 courseId;\n        string title;\n        address tutor;\n        string tutorName;\n        bool isActive;\n    }\n\n    struct Exam {\n        uint256 examId;\n        uint256 courseId;\n        string title;\n        uint256 questionCount;\n        bool isActive;\n        address creator;\n    }\n\n    struct ExamSession {\n        uint256 examId;\n        address student;\n        uint256[] answers;\n        uint256 score;\n        bool isCompleted;\n    }\n\n    // State Variables\n    mapping(address => User) public users;\n    mapping(address => bool) public registeredUsers;\n    mapping(uint256 => Course) public courses;\n    mapping(uint256 => mapping(address => bool)) public courseEnrollments;\n    mapping(uint256 => Exam) public exams;\n    mapping(uint256 => uint256[]) public courseExams;\n    mapping(uint256 => mapping(uint256 => string)) public examQuestions;\n    mapping(uint256 => mapping(uint256 => string[4])) public examOptions;\n    mapping(uint256 => mapping(uint256 => uint256)) public examCorrectAnswers;\n    mapping(uint256 => mapping(address => ExamSession)) public examSessions;\n\n    uint256 public courseCounter;\n    uint256 public examCounter;\n\n    // Events\n    event UserRegistered(address indexed user, string name, Role role);\n    event CourseCreated(\n        uint256 indexed courseId,\n        string title,\n        address indexed tutor\n    );\n    event EnrollmentCreated(address indexed student, uint256 indexed courseId);\n    event ExamCreated(\n        uint256 indexed examId,\n        uint256 indexed courseId,\n        string title\n    );\n    event ExamCompleted(\n        uint256 indexed examId,\n        address indexed student,\n        uint256 score\n    );\n\n    // Modifiers\n    modifier onlyTutor() {\n        require(\n            registeredUsers[msg.sender] && users[msg.sender].role == Role.TUTOR,\n            \"Not a tutor\"\n        );\n        _;\n    }\n\n    modifier onlyStudent() {\n        require(\n            registeredUsers[msg.sender] &&\n                users[msg.sender].role == Role.STUDENT,\n            \"Not a student\"\n        );\n        _;\n    }\n\n    modifier courseExists(uint256 courseId) {\n        require(\n            courseId < courseCounter && courses[courseId].isActive,\n            \"Course not found\"\n        );\n        _;\n    }\n\n    modifier examExists(uint256 examId) {\n        require(\n            examId < examCounter && exams[examId].isActive,\n            \"Exam not found\"\n        );\n        _;\n    }\n\n    // Core User Management\n    function registerUser(string memory name, Role role) public {\n        require(!registeredUsers[msg.sender], \"Already registered\");\n        require(bytes(name).length > 0, \"Name cannot be empty\");\n\n        users[msg.sender] = User({name: name, role: role, isRegistered: true});\n        registeredUsers[msg.sender] = true;\n        emit UserRegistered(msg.sender, name, role);\n    }\n\n    // Core Course Management\n    function createCourse(string memory title) public onlyTutor {\n        require(bytes(title).length > 0, \"Title cannot be empty\");\n\n        uint256 courseId = courseCounter;\n        courses[courseId] = Course({\n            courseId: courseId,\n            title: title,\n            tutor: msg.sender,\n            tutorName: users[msg.sender].name,\n            isActive: true\n        });\n\n        courseCounter++;\n        emit CourseCreated(courseId, title, msg.sender);\n    }\n\n    function enrollInCourse(\n        uint256 courseId\n    ) public onlyStudent courseExists(courseId) {\n        require(!courseEnrollments[courseId][msg.sender], \"Already enrolled\");\n        courseEnrollments[courseId][msg.sender] = true;\n        emit EnrollmentCreated(msg.sender, courseId);\n    }\n\n    // Core Exam Management\n    function createExam(\n        uint256 courseId,\n        string memory title,\n        string[] memory questionTexts,\n        string[4][] memory questionOptions,\n        uint256[] memory correctAnswers\n    ) public onlyTutor courseExists(courseId) {\n        require(courses[courseId].tutor == msg.sender, \"Not course owner\");\n        require(bytes(title).length > 0, \"Title cannot be empty\");\n        require(questionTexts.length > 0, \"At least one question required\");\n        require(\n            questionTexts.length == questionOptions.length,\n            \"Question-options length mismatch\"\n        );\n        require(\n            questionTexts.length == correctAnswers.length,\n            \"Question-answers length mismatch\"\n        );\n\n        uint256 examId = examCounter;\n        exams[examId] = Exam({\n            examId: examId,\n            courseId: courseId,\n            title: title,\n            questionCount: questionTexts.length,\n            isActive: true,\n            creator: msg.sender\n        });\n\n        // Store questions, options, and correct answers\n        for (uint256 i = 0; i < questionTexts.length; i++) {\n            require(\n                bytes(questionTexts[i]).length > 0,\n                \"Question text cannot be empty\"\n            );\n            require(correctAnswers[i] < 4, \"Correct answer index must be 0-3\");\n\n            for (uint256 j = 0; j < 4; j++) {\n                require(\n                    bytes(questionOptions[i][j]).length > 0,\n                    \"Option text cannot be empty\"\n                );\n            }\n\n            examQuestions[examId][i] = questionTexts[i];\n            examOptions[examId][i] = questionOptions[i];\n            examCorrectAnswers[examId][i] = correctAnswers[i];\n        }\n\n        courseExams[courseId].push(examId);\n        examCounter++;\n        emit ExamCreated(examId, courseId, title);\n    }\n\n    // Core Assessment System\n    function takeExam(\n        uint256 examId,\n        uint256[] memory answers\n    ) public onlyStudent examExists(examId) returns (uint256) {\n        Exam storage exam = exams[examId];\n        require(\n            courseEnrollments[exam.courseId][msg.sender],\n            \"Not enrolled in course\"\n        );\n\n        // Return previous score if exam already completed\n        if (examSessions[examId][msg.sender].isCompleted) {\n            return examSessions[examId][msg.sender].score;\n        }\n\n        require(answers.length == exam.questionCount, \"Answer count mismatch\");\n\n        // Validate answer indices\n        for (uint256 i = 0; i < answers.length; i++) {\n            require(answers[i] < 4, \"Answer index must be 0-3\");\n        }\n\n        // Calculate score\n        uint256 correctAnswers = 0;\n        for (uint256 i = 0; i < exam.questionCount; i++) {\n            if (answers[i] == examCorrectAnswers[examId][i]) {\n                correctAnswers++;\n            }\n        }\n\n        // Store exam session\n        examSessions[examId][msg.sender] = ExamSession({\n            examId: examId,\n            student: msg.sender,\n            answers: answers,\n            score: correctAnswers,\n            isCompleted: true\n        });\n\n        emit ExamCompleted(examId, msg.sender, correctAnswers);\n        return correctAnswers;\n    }\n\n    // Essential View Functions\n    function getExamQuestions(\n        uint256 examId\n    )\n        public\n        view\n        examExists(examId)\n        returns (\n            string[] memory questionTexts,\n            string[4][] memory questionOptions\n        )\n    {\n        Exam storage exam = exams[examId];\n        questionTexts = new string[](exam.questionCount);\n        questionOptions = new string[4][](exam.questionCount);\n\n        for (uint256 i = 0; i < exam.questionCount; i++) {\n            questionTexts[i] = examQuestions[examId][i];\n            questionOptions[i] = examOptions[examId][i];\n        }\n\n        return (questionTexts, questionOptions);\n    }\n\n    function getExamResults(\n        uint256 examId,\n        address student\n    )\n        public\n        view\n        examExists(examId)\n        returns (uint256 rawScore, uint256[] memory answers, bool isCompleted)\n    {\n        require(\n            msg.sender == student ||\n                (registeredUsers[msg.sender] &&\n                    users[msg.sender].role == Role.TUTOR),\n            \"Unauthorized access\"\n        );\n\n        ExamSession storage session = examSessions[examId][student];\n        return (session.score, session.answers, session.isCompleted);\n    }\n\n    // NEW FUNCTION: Get past exam questions for revision (MINIMAL VERSION)\n    function getPastExamForRevision(\n        uint256 examId\n    )\n        public\n        view\n        examExists(examId)\n        returns (\n            string[] memory questionTexts,\n            string[4][] memory questionOptions\n        )\n    {\n        Exam storage exam = exams[examId];\n\n        // REMOVED: Enrollment check\n        // REMOVED: Exam completion check\n\n        // Initialize arrays with only questions and options\n        questionTexts = new string[](exam.questionCount);\n        questionOptions = new string[4][](exam.questionCount);\n\n        // Populate only questions and options (no answers)\n        for (uint256 i = 0; i < exam.questionCount; i++) {\n            questionTexts[i] = examQuestions[examId][i];\n            questionOptions[i] = examOptions[examId][i];\n        }\n\n        return (questionTexts, questionOptions);\n    }\n\n    // Course Management Enhancements\n    function getEnrolledCourses(\n        address student\n    ) public view returns (Course[] memory) {\n        Course[] memory enrolledCourses = new Course[](courseCounter);\n        uint256 count = 0;\n\n        for (uint256 i = 0; i < courseCounter; i++) {\n            if (courseEnrollments[i][student] && courses[i].isActive) {\n                enrolledCourses[count] = courses[i];\n                count++;\n            }\n        }\n\n        // Resize array\n        Course[] memory result = new Course[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = enrolledCourses[i];\n        }\n        return result;\n    }\n\n    function getTutorCourses(\n        address tutor\n    ) public view returns (Course[] memory) {\n        Course[] memory tutorCourses = new Course[](courseCounter);\n        uint256 count = 0;\n\n        for (uint256 i = 0; i < courseCounter; i++) {\n            if (courses[i].tutor == tutor && courses[i].isActive) {\n                tutorCourses[count] = courses[i];\n                count++;\n            }\n        }\n\n        Course[] memory result = new Course[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = tutorCourses[i];\n        }\n        return result;\n    }\n\n    // Helper Functions\n    function getCourse(\n        uint256 courseId\n    ) public view courseExists(courseId) returns (Course memory) {\n        return courses[courseId];\n    }\n\n    function getExam(\n        uint256 examId\n    ) public view examExists(examId) returns (Exam memory) {\n        return exams[examId];\n    }\n}\n"
      }
    }
  }
}