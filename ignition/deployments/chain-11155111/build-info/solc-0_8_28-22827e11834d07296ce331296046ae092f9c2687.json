{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-22827e11834d07296ce331296046ae092f9c2687",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ProofHTF.sol": "project/contracts/ProofHTF.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ProofHTF.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\ncontract ProofHTF {\n    // Enums\n    enum Role {\n        TUTOR,\n        STUDENT\n    }\n\n    struct User {\n        string name;\n        Role role;\n        bool isRegistered;\n    }\n\n    struct Course {\n        uint256 courseId;\n        string title;\n        address tutor;\n        string tutorName;\n        bool isActive;\n    }\n\n    struct Exam {\n        uint256 examId;\n        uint256 courseId;\n        string title;\n        uint256 questionCount;\n        bool isActive;\n        address creator;\n    }\n\n    struct ExamSession {\n        uint256 examId;\n        address student;\n        uint256[] answers;\n        uint256 score;\n        bool isCompleted;\n    }\n\n    // State Variables\n    mapping(address => User) public users;\n    mapping(address => bool) public registeredUsers;\n    mapping(uint256 => Course) public courses;\n    mapping(uint256 => mapping(address => bool)) public courseEnrollments;\n    mapping(uint256 => Exam) public exams;\n    mapping(uint256 => uint256[]) public courseExams;\n    mapping(uint256 => mapping(uint256 => string)) public examQuestions;\n    mapping(uint256 => mapping(uint256 => string[4])) public examOptions;\n    mapping(uint256 => mapping(uint256 => uint256)) public examCorrectAnswers;\n    mapping(uint256 => mapping(address => ExamSession)) public examSessions;\n\n    uint256 public courseCounter;\n    uint256 public examCounter;\n\n    // Events\n    event UserRegistered(address indexed user, string name, Role role);\n    event CourseCreated(uint256 indexed courseId, string title, address indexed tutor);\n    event EnrollmentCreated(address indexed student, uint256 indexed courseId);\n    event ExamCreated(uint256 indexed examId, uint256 indexed courseId, string title);\n    event ExamCompleted(uint256 indexed examId, address indexed student, uint256 score);\n\n    // Modifiers\n    modifier onlyTutor() {\n        require(registeredUsers[msg.sender] && users[msg.sender].role == Role.TUTOR, \"Not a tutor\");\n        _;\n    }\n\n    modifier onlyStudent() {\n        require(registeredUsers[msg.sender] && users[msg.sender].role == Role.STUDENT, \"Not a student\");\n        _;\n    }\n\n    modifier courseExists(uint256 courseId) {\n        require(courseId < courseCounter && courses[courseId].isActive, \"Course not found\");\n        _;\n    }\n\n    modifier examExists(uint256 examId) {\n        require(examId < examCounter && exams[examId].isActive, \"Exam not found\");\n        _;\n    }\n\n    // Core User Management\n    function registerUser(string memory name, Role role) public {\n        require(!registeredUsers[msg.sender], \"Already registered\");\n        require(bytes(name).length > 0, \"Name cannot be empty\");\n\n        users[msg.sender] = User({name: name, role: role, isRegistered: true});\n        registeredUsers[msg.sender] = true;\n        emit UserRegistered(msg.sender, name, role);\n    }\n\n    // Core Course Management\n    function createCourse(string memory title) public onlyTutor {\n        require(bytes(title).length > 0, \"Title cannot be empty\");\n\n        uint256 courseId = courseCounter;\n        courses[courseId] = Course({\n            courseId: courseId,\n            title: title,\n            tutor: msg.sender,\n            tutorName: users[msg.sender].name,\n            isActive: true\n        });\n\n        courseCounter++;\n        emit CourseCreated(courseId, title, msg.sender);\n    }\n\n    function enrollInCourse(uint256 courseId) public onlyStudent courseExists(courseId) {\n        require(!courseEnrollments[courseId][msg.sender], \"Already enrolled\");\n        courseEnrollments[courseId][msg.sender] = true;\n        emit EnrollmentCreated(msg.sender, courseId);\n    }\n\n    // Core Exam Management\n    function createExam(\n        uint256 courseId,\n        string memory title,\n        string[] memory questionTexts,\n        string[4][] memory questionOptions,\n        uint256[] memory correctAnswers\n    ) public onlyTutor courseExists(courseId) {\n        require(courses[courseId].tutor == msg.sender, \"Not course owner\");\n        require(bytes(title).length > 0, \"Title cannot be empty\");\n        require(questionTexts.length > 0, \"At least one question required\");\n        require(questionTexts.length == questionOptions.length, \"Question-options length mismatch\");\n        require(questionTexts.length == correctAnswers.length, \"Question-answers length mismatch\");\n\n        uint256 examId = examCounter;\n        exams[examId] = Exam({\n            examId: examId,\n            courseId: courseId,\n            title: title,\n            questionCount: questionTexts.length,\n            isActive: true,\n            creator: msg.sender\n        });\n\n        // Store questions, options, and correct answers\n        for (uint256 i = 0; i < questionTexts.length; i++) {\n            require(bytes(questionTexts[i]).length > 0, \"Question text cannot be empty\");\n            require(correctAnswers[i] < 4, \"Correct answer index must be 0-3\");\n\n            for (uint256 j = 0; j < 4; j++) {\n                require(bytes(questionOptions[i][j]).length > 0, \"Option text cannot be empty\");\n            }\n\n            examQuestions[examId][i] = questionTexts[i];\n            examOptions[examId][i] = questionOptions[i];\n            examCorrectAnswers[examId][i] = correctAnswers[i];\n        }\n\n        courseExams[courseId].push(examId);\n        examCounter++;\n        emit ExamCreated(examId, courseId, title);\n    }\n\n    // Core Assessment System\n    function takeExam(uint256 examId, uint256[] memory answers) public onlyStudent examExists(examId) returns (uint256) {\n        Exam storage exam = exams[examId];\n        require(courseEnrollments[exam.courseId][msg.sender], \"Not enrolled in course\");\n\n        // Return previous score if exam already completed\n        if (examSessions[examId][msg.sender].isCompleted) {\n            return examSessions[examId][msg.sender].score;\n        }\n\n        require(answers.length == exam.questionCount, \"Answer count mismatch\");\n\n        // Validate answer indices\n        for (uint256 i = 0; i < answers.length; i++) {\n            require(answers[i] < 4, \"Answer index must be 0-3\");\n        }\n\n        // Calculate score\n        uint256 correctAnswers = 0;\n        for (uint256 i = 0; i < exam.questionCount; i++) {\n            if (answers[i] == examCorrectAnswers[examId][i]) {\n                correctAnswers++;\n            }\n        }\n\n        // Store exam session\n        examSessions[examId][msg.sender] = ExamSession({\n            examId: examId,\n            student: msg.sender,\n            answers: answers,\n            score: correctAnswers,\n            isCompleted: true\n        });\n\n        emit ExamCompleted(examId, msg.sender, correctAnswers);\n        return correctAnswers;\n    }\n\n    // Essential View Functions\n    function getExamQuestions(uint256 examId)\n        public\n        view\n        examExists(examId)\n        returns (string[] memory questionTexts, string[4][] memory questionOptions)\n    {\n        Exam storage exam = exams[examId];\n        questionTexts = new string[](exam.questionCount);\n        questionOptions = new string[4][](exam.questionCount);\n\n        for (uint256 i = 0; i < exam.questionCount; i++) {\n            questionTexts[i] = examQuestions[examId][i];\n            questionOptions[i] = examOptions[examId][i];\n        }\n\n        return (questionTexts, questionOptions);\n    }\n\n    function getExamResults(uint256 examId, address student)\n        public\n        view\n        examExists(examId)\n        returns (uint256 rawScore, uint256[] memory answers, bool isCompleted)\n    {\n        require(\n            msg.sender == student || (registeredUsers[msg.sender] && users[msg.sender].role == Role.TUTOR),\n            \"Unauthorized access\"\n        );\n\n        ExamSession storage session = examSessions[examId][student];\n        return (session.score, session.answers, session.isCompleted);\n    }\n\n    // NEW FUNCTION: Get past exam questions with answers for revision\n    function getPastExamForRevision(uint256 examId)\n        public\n        view\n        examExists(examId)\n        onlyStudent\n        returns (\n            string[] memory questionTexts,\n            string[4][] memory questionOptions,\n            uint256[] memory correctAnswers,\n            uint256[] memory studentAnswers,\n            bool[] memory isCorrect,\n            uint256 studentScore,\n            uint256 maxScore\n        )\n    {\n        Exam storage exam = exams[examId];\n        ExamSession storage session = examSessions[examId][msg.sender];\n\n        // Check if student is enrolled in the course\n        require(courseEnrollments[exam.courseId][msg.sender], \"Not enrolled in course\");\n\n        // Check if student has completed the exam\n        require(session.isCompleted, \"Must complete exam before viewing revision\");\n\n        // Initialize arrays\n        questionTexts = new string[](exam.questionCount);\n        questionOptions = new string[4][](exam.questionCount);\n        correctAnswers = new uint256[](exam.questionCount);\n        studentAnswers = new uint256[](exam.questionCount);\n        isCorrect = new bool[](exam.questionCount);\n        studentScore = session.score;\n        maxScore = exam.questionCount;\n\n        // Populate all data for comprehensive revision\n        for (uint256 i = 0; i < exam.questionCount; i++) {\n            questionTexts[i] = examQuestions[examId][i];\n            questionOptions[i] = examOptions[examId][i];\n            correctAnswers[i] = examCorrectAnswers[examId][i];\n            studentAnswers[i] = session.answers[i];\n            isCorrect[i] = (session.answers[i] == examCorrectAnswers[examId][i]);\n        }\n\n        return (\n            questionTexts,\n            questionOptions,\n            correctAnswers,\n            studentAnswers,\n            isCorrect,\n            studentScore,\n            maxScore\n        );\n    }\n\n    // Course Management Enhancements\n    function getEnrolledCourses(address student) public view returns (Course[] memory) {\n        Course[] memory enrolledCourses = new Course[](courseCounter);\n        uint256 count = 0;\n        \n        for (uint256 i = 0; i < courseCounter; i++) {\n            if (courseEnrollments[i][student] && courses[i].isActive) {\n                enrolledCourses[count] = courses[i];\n                count++;\n            }\n        }\n        \n        // Resize array\n        Course[] memory result = new Course[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = enrolledCourses[i];\n        }\n        return result;\n    }\n\n    function getTutorCourses(address tutor) public view returns (Course[] memory) {\n        Course[] memory tutorCourses = new Course[](courseCounter);\n        uint256 count = 0;\n        \n        for (uint256 i = 0; i < courseCounter; i++) {\n            if (courses[i].tutor == tutor && courses[i].isActive) {\n                tutorCourses[count] = courses[i];\n                count++;\n            }\n        }\n        \n        Course[] memory result = new Course[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = tutorCourses[i];\n        }\n        return result;\n    }\n\n    // Helper Functions\n    function getCourse(uint256 courseId) public view courseExists(courseId) returns (Course memory) {\n        return courses[courseId];\n    }\n\n    function getExam(uint256 examId) public view examExists(examId) returns (Exam memory) {\n        return exams[examId];\n    }\n}\n"
      }
    }
  }
}